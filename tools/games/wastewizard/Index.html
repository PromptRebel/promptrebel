<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Waste Wizard – Tonnen Defense</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #050510;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      overflow: hidden;
      padding: 10px;
    }
    #gameContainer {
        /* Ensures the canvas scales nicely on mobile while maintaining aspect ratio */
        width: 100%;
        max-width: 800px;
        aspect-ratio: 800 / 600;
        margin: auto;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
      box-shadow: 0 0 30px rgba(0,0,0,0.7);
      border-radius: 16px;
      cursor: pointer; /* Added: Suggests interaction by showing a pointer cursor */
    }
  </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
<script>
(function () {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const WIDTH = 800;
  const HEIGHT = 600;
  const GROUND_Y = HEIGHT - 100;
  const BIN_Y = HEIGHT - 80;
  const BOSS_MAX_HP = 1000;

  // The fixed canvas dimensions are set via HTML attributes but scaled by CSS
  // for responsiveness. The internal game logic uses 800x600.
  // canvas.width = WIDTH; // already set by html attribute
  // canvas.height = HEIGHT; // already set by html attribute

  const WASTE_TYPES = {
    BANANA: "banana",
    NEWSPAPER: "newspaper",
    CARDBOARD: "cardboard",
    DIRTY_CARDBOARD: "dirtyCardboard",
    FOOD: "food",
    FOIL: "foil",
    YOGURT_CUP: "yogurtCup",
    CAN: "can",
    BATTERY: "battery",
    ECIG: "ecig",
    SPRAY_CAN: "sprayCan",
    PAINT_CAN: "paintCan"
  };

  const BIN_TYPES = {
    PAPER:   { color: "#2f7ed8", label: "Papier" },
    RESIDUAL:{ color: "#777777", label: "Restmüll" },
    LVP:     { color: "#f1c40f", label: "Gelber Sack" },
    HAZARD:  { color: "#e74c3c", label: "Problemstoffe" }
  };

  const LEVELS = [
    {
      name: "Level 1 – Papiertonne",
      duration: 20,
      binType: BIN_TYPES.PAPER,
      allowed: [WASTE_TYPES.NEWSPAPER, WASTE_TYPES.CARDBOARD],
      forbidden: [WASTE_TYPES.BANANA, WASTE_TYPES.FOIL, WASTE_TYPES.BATTERY],
      spawnMin: 800,  // ms
      spawnMax: 1600, // ms
      speedMin: 90,   // px/s
      speedMax: 140,
      maxItems: 3,
      errorLimit: 5,
      boss: false
    },
    {
      name: "Level 2 – Restmüll",
      duration: 25,
      binType: BIN_TYPES.RESIDUAL,
      allowed: [WASTE_TYPES.BANANA, WASTE_TYPES.FOOD, WASTE_TYPES.DIRTY_CARDBOARD],
      forbidden: [WASTE_TYPES.NEWSPAPER, WASTE_TYPES.FOIL, WASTE_TYPES.YOGURT_CUP],
      spawnMin: 700,
      spawnMax: 1400,
      speedMin: 110,
      speedMax: 170,
      maxItems: 4,
      errorLimit: 5,
      boss: false
    },
    {
      name: "Level 3 – Gelber Sack",
      duration: 30,
      binType: BIN_TYPES.LVP,
      allowed: [WASTE_TYPES.YOGURT_CUP, WASTE_TYPES.FOIL, WASTE_TYPES.CAN],
      forbidden: [WASTE_TYPES.NEWSPAPER, WASTE_TYPES.BANANA, WASTE_TYPES.BATTERY],
      spawnMin: 600,
      spawnMax: 1200,
      speedMin: 130,
      speedMax: 190,
      maxItems: 5,
      errorLimit: 5,
      boss: false
    },
    {
      name: "Level 4 – Problemstoffe",
      duration: 30,
      binType: BIN_TYPES.HAZARD,
      allowed: [WASTE_TYPES.BATTERY, WASTE_TYPES.ECIG, WASTE_TYPES.SPRAY_CAN, WASTE_TYPES.PAINT_CAN],
      forbidden: [WASTE_TYPES.NEWSPAPER, WASTE_TYPES.FOIL, WASTE_TYPES.BANANA],
      spawnMin: 500,
      spawnMax: 900,
      speedMin: 150,
      speedMax: 220,
      maxItems: 6,
      errorLimit: 5,
      boss: false
    },
    {
      name: "Level 5 – Müllberg-Dämon",
      duration: 45,
      binType: BIN_TYPES.HAZARD,
      allowed: [WASTE_TYPES.BATTERY, WASTE_TYPES.ECIG, WASTE_TYPES.SPRAY_CAN, WASTE_TYPES.PAINT_CAN],
      forbidden: [
        WASTE_TYPES.NEWSPAPER, WASTE_TYPES.FOIL, WASTE_TYPES.BANANA,
        WASTE_TYPES.YOGURT_CUP, WASTE_TYPES.CAN, WASTE_TYPES.FOOD,
        WASTE_TYPES.CARDBOARD, WASTE_TYPES.DIRTY_CARDBOARD
      ],
      spawnMin: 450,
      spawnMax: 850,
      speedMin: 170,
      speedMax: 260,
      maxItems: 7,
      errorLimit: 6,
      boss: true
    }
  ];

  const game = {
    state: "title", // title, intro, running, levelWin, levelFail, final
    currentLevel: 0,
    timeLeft: 0,
    errors: 0,
    waste: [],
    spawnTimer: 0,
    binFlash: 0,
    binFlashColor: null, // "green" | "red"
    bossHp: 0,
    bossFlash: 0,
    lastTime: 0
  };

  // ---------- HELPER FUNCTIONS ----------

  function randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function getCurrentLevel() {
    return LEVELS[game.currentLevel];
  }

  // Get pointer/touch position relative to the canvas internal coordinates (800x600)
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = WIDTH / rect.width;
    const scaleY = HEIGHT / rect.height;
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  // Draw a rounded rectangle
  function roundRect(x, y, w, h, r, fill, stroke) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Lighten or darken a HEX color
  function shadeColor(hex, amount) {
    const num = parseInt(hex.slice(1), 16);
    let r = (num >> 16) + amount;
    let g = ((num >> 8) & 0xff) + amount;
    let b = (num & 0xff) + amount;
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));
    return "#" + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
  }
  
  // Get short name for display
  function kindNameShort(kind) {
    switch (kind) {
      case WASTE_TYPES.BANANA: return "Banane";
      case WASTE_TYPES.NEWSPAPER: return "Zeitung";
      case WASTE_TYPES.CARDBOARD: return "Karton";
      case WASTE_TYPES.DIRTY_CARDBOARD: return "verschmutzter Karton";
      case WASTE_TYPES.FOOD: return "Essensreste";
      case WASTE_TYPES.FOIL: return "Folie";
      case WASTE_TYPES.YOGURT_CUP: return "Joghurtbecher";
      case WASTE_TYPES.CAN: return "Dose";
      case WASTE_TYPES.BATTERY: return "Batterie";
      case WASTE_TYPES.ECIG: return "E-Zigarette";
      case WASTE_TYPES.SPRAY_CAN: return "Spraydose";
      case WASTE_TYPES.PAINT_CAN: return "Farb-/Lackdose";
      default: return "?";
    }
  }


  // ---------- DRAWING: BACKGROUND / BIN / BOSS ----------

  function drawBackground() {
    // Gradient sky/wall
    const grad = ctx.createRadialGradient(
      WIDTH / 2, HEIGHT / 3, 50,
      WIDTH / 2, HEIGHT / 2, HEIGHT
    );
    grad.addColorStop(0, "#181a3a");
    grad.addColorStop(1, "#050510");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wall panels/lines
    ctx.strokeStyle = "#141426";
    ctx.lineWidth = 2;
    for (let i = 0; i <= 8; i++) {
      const x = (WIDTH / 8) * i;
      ctx.beginPath();
      ctx.moveTo(x, 80);
      ctx.lineTo(x, GROUND_Y);
      ctx.stroke();
    }

    // Floor
    const floorGrad = ctx.createLinearGradient(0, GROUND_Y, 0, HEIGHT);
    floorGrad.addColorStop(0, "#11111c");
    floorGrad.addColorStop(1, "#050508");
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

    // Top light strip
    ctx.fillStyle = "#2b2d4f";
    ctx.fillRect(WIDTH / 2 - 120, 60, 240, 18);
    ctx.fillStyle = "#9ea4ff22";
    ctx.fillRect(WIDTH / 2 - 110, 62, 220, 14);
  }

  function drawBin() {
    const lvl = getCurrentLevel();
    const bin = lvl.binType;
    const cx = WIDTH / 2;
    const cy = BIN_Y;
    const w = 150;
    const h = 110;
    const r = 14;

    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(cx, GROUND_Y + 40, 110, 26, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    const bodyColor = bin.color;
    const bodyGrad = ctx.createLinearGradient(cx - w/2, cy - h, cx + w/2, cy + h);
    bodyGrad.addColorStop(0, shadeColor(bodyColor, -20));
    bodyGrad.addColorStop(0.5, bodyColor);
    bodyGrad.addColorStop(1, shadeColor(bodyColor, 15));

    ctx.fillStyle = bodyGrad;
    roundRect(cx - w / 2, cy - h, w, h, r, true, false);

    // Lid
    ctx.fillStyle = shadeColor(bodyColor, -25);
    roundRect(cx - w / 2 - 10, cy - h - 25, w + 20, 22, 10, true, false);

    ctx.fillStyle = "#0008";
    ctx.fillRect(cx - 35, cy - h - 19, 70, 6);

    // Label
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = (bin === BIN_TYPES.LVP) ? "#333" : "#fefefe";
    ctx.font = "bold 26px 'Inter'";
    ctx.fillText(bin.label, cx, cy - 35);

    // Bin-Flash (Hit effect)
    if (game.binFlash > 0 && game.binFlashColor) {
      const alpha = game.binFlash / 20;
      ctx.fillStyle = game.binFlashColor === "green"
        ? `rgba(0,255,120,${0.35 * alpha})`
        : `rgba(255,60,60,${0.45 * alpha})`;
      roundRect(cx - w / 2 - 10, cy - h - 25, w + 20, h + 40, 18, true, false);
    }
  }

  function drawBoss() {
    const lvl = getCurrentLevel();
    if (!lvl.boss) return;

    const x = WIDTH / 2;
    const y = 140;

    ctx.save();

    // Garbage Heap Shape
    const hpRatio = Math.max(0, game.bossHp) / BOSS_MAX_HP;
    const baseColor = hpRatio > 0.5 ? "#3b7f3b" : "#7e3b7f";
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.moveTo(x - 190, y + 90);
    ctx.quadraticCurveTo(x - 160, y - 40, x - 60, y - 80);
    ctx.quadraticCurveTo(x, y - 120, x + 60, y - 80);
    ctx.quadraticCurveTo(x + 160, y - 40, x + 190, y + 90);
    ctx.quadraticCurveTo(x + 90, y + 130, x, y + 110);
    ctx.quadraticCurveTo(x - 90, y + 130, x - 190, y + 90);
    ctx.closePath();
    ctx.fill();

    // Garbage "pimples"
    ctx.fillStyle = shadeColor(baseColor, -25);
    for (let i = 0; i < 15; i++) {
      const px = x + (Math.random() * 260 - 130);
      const py = y + (Math.random() * 120 - 10);
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.arc(px, py, Math.random() * 14 + 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Eyes
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(x - 55, y - 30, 26, 0, Math.PI * 2);
    ctx.arc(x + 55, y - 30, 26, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#e53935";
    ctx.beginPath();
    ctx.arc(x - 55, y - 28, 16, 0, Math.PI * 2);
    ctx.arc(x + 55, y - 28, 16, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x - 60, y - 32, 6, 0, Math.PI * 2);
    ctx.arc(x + 50, y - 32, 6, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(x - 70, y + 20);
    ctx.quadraticCurveTo(x, y + 70, x + 70, y + 20);
    ctx.stroke();

    // Teeth
    ctx.fillStyle = "#fafafa";
    for (let i = -60; i <= 60; i += 20) {
      ctx.beginPath();
      ctx.moveTo(x + i, y + 28);
      ctx.lineTo(x + i + 8, y + 48);
      ctx.lineTo(x + i + 16, y + 28);
      ctx.closePath();
      ctx.fill();
    }

    // HP-Bar
    const barW = 240;
    const barH = 18;
    const barX = x - barW / 2;
    const barY = y + 115;
    ctx.fillStyle = "#000a";
    roundRect(barX, barY, barW, barH, 8, true, false);
    ctx.fillStyle = "#e53935";
    roundRect(barX + 2, barY + 2, (barW - 4) * hpRatio, barH - 4, 6, true, false);

    ctx.fillStyle = "#fff";
    ctx.font = "12px 'Inter'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`Müllberg-HP: ${Math.max(0, game.bossHp)} / ${BOSS_MAX_HP}`, x, barY - 10);

    // Hit Flash
    if (game.bossFlash > 0) {
      const a = game.bossFlash / 15;
      ctx.fillStyle = `rgba(255,255,255,${0.5 * a})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }

    ctx.restore();
  }

  // ---------- DRAWING: WASTE SHAPES (12 types) ----------

  function drawBanana(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    ctx.rotate(-0.4);
    // Peel (yellow crescent)
    ctx.fillStyle = "#ffeb3b";
    ctx.strokeStyle = "#f9a825";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(-40, 0);
    ctx.quadraticCurveTo(-10, -35, 40, -10);
    ctx.quadraticCurveTo(5, 20, -40, 10);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Inner light side
    ctx.fillStyle = "#fff9c4";
    ctx.beginPath();
    ctx.moveTo(-30, 0);
    ctx.quadraticCurveTo(-5, -23, 30, -7);
    ctx.quadraticCurveTo(3, 10, -30, 6);
    ctx.closePath();
    ctx.fill();
    // Stem & brown ends
    ctx.fillStyle = "#5d4037";
    ctx.beginPath();
    ctx.roundRect(-44, -4, 5, 8, 2);
    ctx.roundRect(40, -6, 6, 12, 2);
    ctx.fill();
    ctx.restore();
  }

  function drawNewspaper(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Folded stack
    ctx.fillStyle = "#f5f5f5";
    ctx.strokeStyle = "#b0b0b0";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-40, -25);
    ctx.lineTo(40, -25);
    ctx.lineTo(32, 25);
    ctx.lineTo(-48, 25);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Text columns
    ctx.fillStyle = "#9e9e9e";
    for (let i = -30; i <= 10; i += 10) {
      ctx.fillRect(i, -18, 50, 3);
      ctx.fillRect(i, -8, 52, 3);
      ctx.fillRect(i, 2, 48, 3);
      ctx.fillRect(i, 12, 44, 3);
    }
    // Small icon (Masthead)
    ctx.fillStyle = "#3949ab";
    ctx.fillRect(-33, -20, 18, 12);
    ctx.restore();
  }

  function drawCardboard(ctx, x, y, s, dirty) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Box
    ctx.fillStyle = dirty ? "#a6773b" : "#d7b58a";
    ctx.strokeStyle = "#8d6e63";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-40, 20);
    ctx.lineTo(40, 20);
    ctx.lineTo(28, -25);
    ctx.lineTo(-52, -25);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Fold lines
    ctx.strokeStyle = "#6d4c41";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-10, -25);
    ctx.lineTo(-5, 20);
    ctx.moveTo(10, -25);
    ctx.lineTo(5, 20);
    ctx.stroke();
    if (dirty) {
      ctx.fillStyle = "rgba(93,64,55,0.7)"; // Dirt smear
      ctx.beginPath();
      ctx.ellipse(-10, -5, 16, 10, 0, 0, Math.PI * 2);
      ctx.ellipse(18, 3, 12, 8, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawFoodWaste(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Slump heap
    ctx.fillStyle = "#bca281";
    ctx.beginPath();
    ctx.moveTo(-30, 15);
    ctx.quadraticCurveTo(-40, -5, -10, -15);
    ctx.quadraticCurveTo(5, -25, 25, -10);
    ctx.quadraticCurveTo(35, 5, 18, 18);
    ctx.quadraticCurveTo(0, 25, -30, 15);
    ctx.fill();
    // Green vegetable bits
    ctx.fillStyle = "#66bb6a";
    ctx.beginPath();
    ctx.arc(-5, -5, 5, 0, Math.PI * 2);
    ctx.arc(10, 2, 4, 0, Math.PI * 2);
    ctx.fill();
    // Bone (as an example of meat waste)
    ctx.fillStyle = "#f5f5f5";
    ctx.beginPath();
    ctx.roundRect(-5, -2, 26, 8, 4);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-5, 2, 5, 0, Math.PI * 2);
    ctx.arc(21, 2, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawFoil(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Wrinkled shape
    const grad = ctx.createLinearGradient(-40, -30, 40, 30);
    grad.addColorStop(0, "#cfd8dc");
    grad.addColorStop(0.5, "#ffffff");
    grad.addColorStop(1, "#90a4ae");
    ctx.fillStyle = grad;
    ctx.strokeStyle = "#78909c";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-35, -10);
    ctx.quadraticCurveTo(-15, -30, 10, -25);
    ctx.quadraticCurveTo(40, -10, 32, 10);
    ctx.quadraticCurveTo(5, 35, -25, 20);
    ctx.quadraticCurveTo(-40, 5, -35, -10);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Glint
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(-10, -15);
    ctx.quadraticCurveTo(0, -25, 12, -18);
    ctx.quadraticCurveTo(6, -10, -2, -8);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawYogurtCup(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Cup body
    ctx.fillStyle = "#fafafa";
    ctx.strokeStyle = "#b0bec5";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-20, -22);
    ctx.lineTo(20, -22);
    ctx.lineTo(14, 24);
    ctx.lineTo(-14, 24);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Lid (foil/plastic)
    ctx.fillStyle = "#e3f2fd";
    ctx.beginPath();
    ctx.roundRect(-24, -28, 48, 8, 4);
    ctx.fill();
    ctx.strokeStyle = "#90caf9";
    ctx.stroke();

    // Label
    ctx.fillStyle = "#42a5f5";
    ctx.fillRect(-16, -10, 32, 14);
    ctx.fillStyle = "#fff";
    ctx.font = "10px 'Inter'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Joghurt", 0, -3);
    ctx.restore();
  }

  function drawCan(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Body
    const grad = ctx.createLinearGradient(0, -30, 0, 30);
    grad.addColorStop(0, "#eceff1");
    grad.addColorStop(1, "#b0bec5");
    ctx.fillStyle = grad;
    ctx.strokeStyle = "#78909c";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-18, -28, 36, 56, 6);
    ctx.fill();
    ctx.stroke();
    // Top & Bottom
    ctx.fillStyle = "#90a4ae";
    ctx.beginPath();
    ctx.ellipse(0, -28, 18, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0, 28, 18, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Label
    ctx.fillStyle = "#e53935";
    ctx.fillRect(-14, -10, 28, 20);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 12px 'Inter'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Dose", 0, 0);
    ctx.restore();
  }

  function drawBattery(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Body
    ctx.fillStyle = "#ffb300";
    ctx.strokeStyle = "#5d4037";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-10, -26, 20, 52, 6);
    ctx.fill();
    ctx.stroke();
    // Positive end
    ctx.fillStyle = "#424242";
    ctx.fillRect(-7, -32, 14, 6);
    ctx.fillStyle = "#f5f5f5";
    ctx.font = "bold 14px 'Inter'";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("+", 0, -10);
    ctx.fillText("-", 0, 12);
    ctx.restore();
  }

  function drawECig(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    ctx.rotate(Math.PI / 5);
    // Body
    ctx.fillStyle = "#263238";
    ctx.beginPath();
    ctx.roundRect(-8, -30, 16, 60, 6);
    ctx.fill();
    // Metal ring
    ctx.fillStyle = "#90a4ae";
    ctx.fillRect(-8, -8, 16, 6);
    // Mouthpiece
    ctx.fillStyle = "#cfd8dc";
    ctx.beginPath();
    ctx.roundRect(-6, -38, 12, 10, 4);
    ctx.fill();
    // LED light
    ctx.fillStyle = "#e53935";
    ctx.beginPath();
    ctx.arc(0, 28, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawSprayCan(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Body
    ctx.fillStyle = "#ff7043";
    ctx.strokeStyle = "#bf360c";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-16, -24, 32, 52, 6);
    ctx.fill();
    ctx.stroke();
    // Cap
    ctx.fillStyle = "#263238";
    ctx.beginPath();
    ctx.roundRect(-12, -34, 24, 12, 4);
    ctx.fill();
    // Spray button
    ctx.fillStyle = "#fafafa";
    ctx.fillRect(-4, -34, 8, 6);
    // Spray Symbol
    ctx.fillStyle = "#fff3e0";
    ctx.beginPath();
    ctx.moveTo(-10, 10);
    ctx.lineTo(0, 0);
    ctx.lineTo(10, 10);
    ctx.lineTo(0, 20);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawPaintCan(ctx, x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(s, s);
    // Can body
    ctx.fillStyle = "#cfd8dc";
    ctx.strokeStyle = "#607d8b";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-20, -22, 40, 46, 6);
    ctx.fill();
    ctx.stroke();
    // Lid
    ctx.fillStyle = "#90a4ae";
    ctx.beginPath();
    ctx.ellipse(0, -22, 20, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Paint band
    ctx.fillStyle = "#42a5f5";
    ctx.fillRect(-16, -4, 32, 16);
    // Dripping paint
    ctx.fillStyle = "#42a5f5";
    ctx.beginPath();
    ctx.moveTo(10, 12);
    ctx.quadraticCurveTo(18, 32, 6, 40);
    ctx.quadraticCurveTo(2, 36, -2, 40);
    ctx.quadraticCurveTo(-10, 30, -6, 14);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawWasteLabel(ctx, x, y, text) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.font = "10px 'Inter'";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(text, 0, 22);
    ctx.restore();
  }

  function drawWasteItem(item, time) {
    // Adds a slight wobble animation
    const wobble = 0.1 * Math.sin(time / 250 + item.x * 0.05);
    const scale = 0.9 + wobble;
    switch (item.kind) {
      case WASTE_TYPES.BANANA:
        drawBanana(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Banane");
        break;
      case WASTE_TYPES.NEWSPAPER:
        drawNewspaper(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Zeitung");
        break;
      case WASTE_TYPES.CARDBOARD:
        drawCardboard(ctx, item.x, item.y, scale, false);
        drawWasteLabel(ctx, item.x, item.y, "Karton");
        break;
      case WASTE_TYPES.DIRTY_CARDBOARD:
        drawCardboard(ctx, item.x, item.y, scale, true);
        drawWasteLabel(ctx, item.x, item.y, "verschm. Karton");
        break;
      case WASTE_TYPES.FOOD:
        drawFoodWaste(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Essensreste");
        break;
      case WASTE_TYPES.FOIL:
        drawFoil(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Folie");
        break;
      case WASTE_TYPES.YOGURT_CUP:
        drawYogurtCup(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Joghurtbecher");
        break;
      case WASTE_TYPES.CAN:
        drawCan(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Dose");
        break;
      case WASTE_TYPES.BATTERY:
        drawBattery(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Batterie");
        break;
      case WASTE_TYPES.ECIG:
        drawECig(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "E-Zigarette");
        break;
      case WASTE_TYPES.SPRAY_CAN:
        drawSprayCan(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Spraydose");
        break;
      case WASTE_TYPES.PAINT_CAN:
        drawPaintCan(ctx, item.x, item.y, scale);
        drawWasteLabel(ctx, item.x, item.y, "Farbrest");
        break;
    }
  }

  // ---------- GAME LOGIC ----------

  function createWaste(level) {
    const pool = level.allowed.concat(level.forbidden);
    const kind = pool[Math.floor(Math.random() * pool.length)];
    return {
      kind,
      x: 80 + Math.random() * (WIDTH - 160),
      y: -40,
      vy: randRange(level.speedMin, level.speedMax), // speed in px/s
      radius: 34 // Hitbox radius
    };
  }

  function resetLevel(levelIndex) {
    game.currentLevel = levelIndex;
    const lvl = getCurrentLevel();
    game.timeLeft = lvl.duration;
    game.errors = 0;
    game.waste = [];
    game.spawnTimer = 0;
    game.binFlash = 0;
    game.binFlashColor = null;
    game.bossHp = lvl.boss ? BOSS_MAX_HP : 0;
    game.bossFlash = 0;
  }

  function startIntro(levelIndex) {
    resetLevel(levelIndex);
    game.state = "intro";
  }

  function startGame() {
    const lvl = getCurrentLevel();
    game.state = "running";
    game.timeLeft = lvl.duration;
  }

  function handleWasteReachedBin(w, level) {
    const allowed = new Set(level.allowed);
    const isAllowed = allowed.has(w.kind);

    if (isAllowed) {
      game.binFlash = 20;
      game.binFlashColor = "green";
      
      // If it's the boss level, allowed waste hits the boss (and prevents error)
      if (level.boss) {
        game.bossHp -= 50; // Damage the boss
        game.bossFlash = 15;
        if (game.bossHp <= 0 && game.errors <= level.errorLimit) {
          game.state = "levelWin"; // Boss defeated!
        }
      } 
      // Non-boss levels: correct waste is sorted, no score change.
      
    } else {
      // Incorrect waste enters the bin (Error)
      game.errors++;
      game.binFlash = 22;
      game.binFlashColor = "red";
      if (game.errors > level.errorLimit) {
        game.state = "levelFail";
      }
    }
  }

  function updateGame(dt, now) {
    if (game.state !== "running") return;

    const lvl = getCurrentLevel();
    game.timeLeft -= dt / 1000;
    if (game.binFlash > 0) game.binFlash -= dt / 16;
    if (game.bossFlash > 0) game.bossFlash -= dt / 16;

    // Spawn new waste item
    game.spawnTimer -= dt;
    if (game.spawnTimer <= 0 && game.waste.length < lvl.maxItems) {
      game.waste.push(createWaste(lvl));
      game.spawnTimer = randRange(lvl.spawnMin, lvl.spawnMax);
    }

    // Update position and check for bin collision
    for (let i = game.waste.length - 1; i >= 0; i--) {
      const w = game.waste[i];
      w.y += w.vy * dt / 1000;

      // Check if waste has reached the bin level
      if (w.y >= BIN_Y - 10) {
        handleWasteReachedBin(w, lvl);
        game.waste.splice(i, 1);
      }
    }

    // Check for end of time
    if (game.timeLeft <= 0 && game.state === "running") {
      if (lvl.boss) {
        // Boss level: must defeat boss AND be within error limit
        if (game.bossHp <= 0 && game.errors <= lvl.errorLimit) {
          game.state = "levelWin";
        } else {
          game.state = "levelFail";
        }
      } else {
        // Standard level: must be within error limit
        game.state = (game.errors <= lvl.errorLimit) ? "levelWin" : "levelFail";
      }
    }
  }

  function drawHUD() {
    if (game.state !== "running") return;
    const lvl = getCurrentLevel();

    ctx.fillStyle = "#ffffff";
    ctx.font = "18px 'Inter'";
    ctx.textBaseline = "top";

    ctx.textAlign = "left";
    ctx.fillText(lvl.name, 20, 18);

    ctx.textAlign = "center";
    ctx.fillText(`Zeit: ${Math.max(0, Math.ceil(game.timeLeft))} s`, WIDTH / 2, 18);

    ctx.textAlign = "right";
    ctx.fillText(`Fehler: ${game.errors} / ${lvl.errorLimit}`, WIDTH - 20, 18);
  }

  function drawOverlay() {
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ffffff";

    if (game.state === "title") {
      ctx.font = "bold 46px 'Inter'";
      ctx.fillText("Waste Wizard", WIDTH / 2, HEIGHT / 2 - 80);
      ctx.font = "28px 'Inter'";
      ctx.fillText("Tonnen Defense", WIDTH / 2, HEIGHT / 2 - 35);
      ctx.font = "20px 'Inter'";
      ctx.fillText("Klick / Tap zum Starten", WIDTH / 2, HEIGHT / 2 + 40);
    } else if (game.state === "intro") {
      const lvl = getCurrentLevel();
      ctx.font = "bold 32px 'Inter'";
      ctx.fillText(lvl.name, WIDTH / 2, HEIGHT / 2 - 80);
      ctx.font = "20px 'Inter'";
      if (lvl.boss) {
        ctx.fillText("Endboss! Nur Problemstoffe treffen den Müllberg-Dämon.", WIDTH / 2, HEIGHT / 2 - 20);
        ctx.fillText("Alle anderen Stoffe: Wegklicken, bevor sie die Tonne erreichen.", WIDTH / 2, HEIGHT / 2 + 10);
      } else {
        ctx.fillText(`Tonne: ${lvl.binType.label}`, WIDTH / 2, HEIGHT / 2 - 10);
        ctx.fillText("Erlaubt (müssen in die Tonne):", WIDTH / 2, HEIGHT / 2 + 20);
        ctx.font = "18px 'Inter'";
        const allowedNames = lvl.allowed.map(kindNameShort).join(", ");
        ctx.fillText(allowedNames, WIDTH / 2, HEIGHT / 2 + 50);
        ctx.font = "20px 'Inter'";
        ctx.fillText("Falsche Abfälle anklicken / antippen (bevor sie in die Tonne fallen).", WIDTH / 2, HEIGHT / 2 + 90);
      }
      ctx.font = "18px 'Inter'";
      ctx.fillText("Klick / Tap um zu starten", WIDTH / 2, HEIGHT / 2 + 140);
    } else if (game.state === "levelWin") {
      const lvl = getCurrentLevel();
      ctx.font = "bold 40px 'Inter'";
      ctx.fillText("Level bestanden!", WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = "22px 'Inter'";
      ctx.fillText(`${lvl.name}`, WIDTH / 2, HEIGHT / 2);
      ctx.fillText(`Fehler: ${game.errors} / ${lvl.errorLimit}`, WIDTH / 2, HEIGHT / 2 + 40);
      ctx.font = "18px 'Inter'";
      ctx.fillText(
        (game.currentLevel === LEVELS.length - 1)
          ? "Klick / Tap für den Abschlussscreen"
          : "Klick / Tap für das nächste Level",
        WIDTH / 2,
        HEIGHT / 2 + 90
      );
    } else if (game.state === "levelFail") {
      const lvl = getCurrentLevel();
      ctx.font = "bold 40px 'Inter'";
      ctx.fillText("Level nicht bestanden", WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = "22px 'Inter'";
      const reason = (game.errors > lvl.errorLimit) ? "Zu viele Fehler" : "Zeit abgelaufen";
      ctx.fillText(reason, WIDTH / 2, HEIGHT / 2);
      ctx.fillText(`Fehler: ${game.errors} / ${lvl.errorLimit}`, WIDTH / 2, HEIGHT / 2 + 40);
      ctx.font = "18px 'Inter'";
      ctx.fillText("Klick / Tap zum erneuten Versuch", WIDTH / 2, HEIGHT / 2 + 90);
    } else if (game.state === "final") {
      ctx.font = "bold 42px 'Inter'";
      ctx.fillText("Interaktive Abfall-Unterweisung", WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = "32px 'Inter'";
      ctx.fillText("erfolgreich abgeschlossen!", WIDTH / 2, HEIGHT / 2);
      ctx.font = "18px 'Inter'";
      ctx.fillText("Klick / Tap zum Neustart ab Level 1", WIDTH / 2, HEIGHT / 2 + 70);
    }
  }

  // ---------- INPUT HANDLERS ----------

  function handlePointerDown(e) {
    e.preventDefault();
    const pos = getPointerPos(e);

    if (game.state === "running") {
      handleClickOnWaste(pos.x, pos.y);
    } else {
      advanceState();
    }
  }

  function handleClickOnWaste(x, y) {
    const lvl = getCurrentLevel();
    const allowed = new Set(lvl.allowed);

    for (let i = game.waste.length - 1; i >= 0; i--) {
      const w = game.waste[i];
      const dx = w.x - x;
      const dy = w.y - y;
      
      // Check for click/tap hit
      if (dx * dx + dy * dy <= (w.radius * w.radius)) {
        const isAllowed = allowed.has(w.kind);
        
        if (isAllowed) {
          // Clicked/Tapped on allowed waste (should have let it fall) -> Error
          game.errors++;
          game.binFlash = 22;
          game.binFlashColor = "red";
          if (game.errors > lvl.errorLimit) {
            game.state = "levelFail";
          }
        } else {
          // Clicked/Tapped on forbidden waste (successfully defended)
          game.binFlash = 18;
          game.binFlashColor = "green";
        }
        
        // Remove item after interaction
        game.waste.splice(i, 1);
        return;
      }
    }
  }

  function advanceState() {
    if (game.state === "title") {
      startIntro(0);
    } else if (game.state === "intro") {
      startGame();
    } else if (game.state === "levelWin") {
      if (game.currentLevel >= LEVELS.length - 1) {
        game.state = "final";
      } else {
        startIntro(game.currentLevel + 1);
      }
    } else if (game.state === "levelFail") {
      startIntro(game.currentLevel);
    } else if (game.state === "final") {
      startIntro(0);
    }
  }

  // Event Listeners for both mouse and touch
  canvas.addEventListener("mousedown", handlePointerDown, { passive: false });
  canvas.addEventListener("touchstart", handlePointerDown, { passive: false });

  // ---------- GAME LOOP ----------

  function loop(timestamp) {
    if (!game.lastTime) game.lastTime = timestamp;
    const dt = timestamp - game.lastTime;
    game.lastTime = timestamp;

    updateGame(dt, timestamp);

    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawBin();
    drawBoss();
    const now = performance.now();
    for (const w of game.waste) {
      drawWasteItem(w, now);
    }
    drawHUD();
    if (game.state !== "running") {
      drawOverlay();
    }

    requestAnimationFrame(loop);
  }

  // ---------- START GAME ----------

  game.state = "title";
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

